1. C 和 C++ 有什么区别 ?

        答：c++在c的基础上增添类，C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。

2. const 有什么用途

主要有三点：

    1：定义只读变量，即常量.

    2：修饰函数的参数和函数的返回值.

    3： 修饰函数的定义体，这里的函数为类的成员函数，被const修饰的成员函数代表不修改成员变量的值.

3.指针和引用的区别

    1：引用是变量的一个别名，内部实现是只读指针

    2：引用只能在初始化时被赋值，其他时候值不能被改变，指针的值可以在任何时候被改变

    3：引用不能为NULL，指针可以为NULL

    4：引用变量内存单元保存的是被引用变量的地址

    5：“sizeof 引用" = 指向变量的大小 ， "sizeof 指针"= 指针本身的大小

    6：引用可以取地址操作，返回的是被引用变量本身所在的内存单元地址

    7：引用使用在源代码级相当于普通的变量一样使用，做函数参数时，内部传递的实际是变量地址
    
4.C++中有了malloc / free , 为什么还需要 new / delete     

    1:malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。
    2:对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。
      对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。
      由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。
    3:因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。
  
5. 编写类String 的构造函数，析构函数，拷贝构造函数和赋值函数
```
#include <bits/stdc++.h>
#include <cstring>
using namespace std;
class String {
public:
  String(const char *str = NULL); // 普通构造函数
  String(const String &other); // 拷贝构造函数
  ~String(void); // 析构函数
  String & operator =(const String &other); // 赋值函数
private:
  char *data; // 用来保存字符串
};

// 普通构造函数
String::String(const char *str) {
  if(str == NULL) {
    data = new char[1];
    *data = '\0'; // 结束标志'\0'
  }
  else {
    int length = strlen(str);
    data = new char[length + 1];
    strcpy(data,str);
  }
}
// 析构函数
String::~String(void) {
  delete []data;
}
// 拷贝构造函数
String::String(const String &other) {
  int length = strlen(other.data);
  data = new char[length + 1];
  strcpy(data,other.data);
}
// 赋值函数
String &String::operator =(const String &other) {
  if(this == &other) { // 检查自赋值
    return *this;
  }
  delete []data;
  int length = strlen(other.data);
  data = new char[length + 1];
  strcpy(data, other.data);
  return *this; // 返回本对象的引用
}

int main(int argc, char const *argv[]) {
  String s = "asdasd";
  String a;
  String b("abc");
  // printf("%s\n", b.data); // 因为定义了private,封装了所以访问不了
  return 0;
}

```
 

    


