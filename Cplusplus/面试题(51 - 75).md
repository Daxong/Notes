### 51. 说下你对内存的了解？
```
1.栈 - 由编译器自动分配释放
2.堆 - 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收
3.全局区(静态区)，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，
  未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。- 程序结束释放
4.另外还有一个专门放常量的地方。- 程序结束释放
5.程序代码区，存放2进制代码。
  在函数体中定义的变量通常是在栈上，用malloc， calloc， realloc等分配内存的函数分配得到的就是在堆上。
  在所有函数体外定义的是全局量，加了static修饰符后不管在哪里都存放在全局区(静态区)。
  在所有函数体外定义的static变量表示在该文件中有效，不能extern到别的文件用，在函数体内定义的static表示只在该函数体内有效。
  另外，函数中的"adgfdf"这样的字符串存放在常量区。
```
### 52.如何初始化一个指针数组.
```
首先明确一个概念，就是指向数组的指针，和存放指针的数组。 
指向数组的指针：char (*array)[5]; 含义是一个指向存放5个字符的数组的指针。 
存放指针的数组：char *array[5];含义是一个数组中存放了5个指向字符型数据的指针。 
按照题意，我理解为初始化一个存放指针的数组，char *array[2]={“China”,”Beijing”};
其含义是初始化了一个有两个指向字符型数据的指针的数组，这两个指针分别指向字符串”China”和”Beijing”。
```
### 53.关键字const是什么含意？
```
我只要一听到被面试者说：“const意味着常数”，我就知道我正在和一个业余者打交道。
去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的
每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，
只要能说出const意味着“只读”就可以了。
尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。
（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）
如果应试者能正确回答这 个问题，我将问他一个附加的问题：下面的声明都是什么意思？
```
```
const int a;

int const a;

const int *a;

int * const a;

int const * a const;

前两个的作用是一样，a是一个常整型数。
第三个意味着a是一个指向常整型数的指针(也就是，整型数是不可修改的，但指针可以)。
第四个意思a是一个指向整 型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。
最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型 数是不可修改的，同时指针也是不可修改的）。
如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。
顺带提一句，也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，
那么我为什么还要如此看重关键字const呢？我也如下的几下理由： 
1). 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。
如果你曾花很多时间清理 其它人留下的垃圾，你就会很快学会感谢这点多余的信息。
（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。） 
2). 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。 
3). 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。
简而言之，这样可以减少bug的出现。
```
### 54.什么是动态特性?
```
在绝大多数情况下， 程序的功能是在编译的时候就确定下来的， 我们称之为静态特性。 
反之， 如果程序的功能是在运行时刻才能确定下来的， 则称之为动态特性。
C++中， 虚函数，抽象基类， 动态绑定和多态构成了出色的动态特性。
```
### 55.基类的有1个虚函数，子类还需要申明为 virtual吗？为什么。
```
不申明没有关系的。 不过，我总是喜欢显式申明，使得代码更加清晰。
```
### 56.在C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”声明？
```
函数和变量被C++编译后在符号库中的名字与C语言的不同，被extern “C”修饰的变量和函数是按照C语言方式编译和连接的。
由于编译后的名字不同，C++程序不能直接调用C 函数。C++提供了一个C 连接交换指定符号extern“C”来解决这个问题。
```
### 57.如何定义Bool变量的TRUE和FALSE的值.
```
一般来说先要把TURE和FALSE给定义了.
使用#define就可以： 
#define TURE 1 
#define FALSE 0 
如果有一个变量需要定义成bool型的，
举个例子：
bool a = TURE;
就可以了
```
### 58.内联函数 inline 和宏定义一起使用的区别.
```
内联函数是在编译的时候已经做好将对应的函数代码替换嵌入到对应的位置，适用于代码较少的函数。 
宏定义是简单的替换变量，如果定义的是有参数的函数形式，参数不做类型校验。
```
### 59.ICMP是什么协议,处于哪一层?
```
Internet控制报文协议，处于网络层（IP层）
```
### 60. C 中 static 有什么作用?
```
(1)隐藏。 
当我们同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性，
故使用static在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。

(2)static的第二个作用是保持变量内容的持久。
存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。
共有两种变量存储在静态存储区：全局变量和static变量。

(3)static的第三个作用是默认初始化为0。
其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。
在静态数据区，内存中所有的字节默认值都是0×00,某些时候这一特点可以减少程序员的工作量。
```
### 61. malloc 和 new 的区别。
```
1、malloc/free是C/C++中的方法（函数），new/delete是C++中的操作符。
2、malloc申请的是heap区的内存空间，而new则是申请的free store区的内存空间。
3、使用free之前要判断，使其free的指针是！NULL的，使用delete则无须判断。
4、free掉的内存是该指针指向的一段内存空间，里面应该是空的。而delete掉的内存是里面确实存有数据或者对象的。
```
### 62. malloc 最大能申请多大的内存.(我8G内存能申请1.7G左右)
测试代码：
```
#include <bits/stdc++.h>

using namespace std;

int main(int argc, char const *argv[]) {
  unsigned int blocksize[] = {1024 * 1024, 1024, 1};
  int max = 0;
  for(int i = 0; i < 3; i++) {
    for(int cnt = 1; ; cnt++) {
      void* block = malloc(max + blocksize[i] * cnt);
      if(block) {
        max += blocksize[i] * cnt;
        free(block);
      }
      else {
        break;
      }
    }
  }
  std::cout << "max malloc size = " << max <<  "B \n";
  std::cout << "max malloc size = " << 1. * max / 1024.0 / 1024.0 / 1024.0 << "GB \n";
  return 0;
}

```
### 63.C++ 空类，默认产生哪些成员函数?
```
默认构造函数、默认拷贝构造函数、默认析构函数、默认赋值运算符 这四个是我们通常大都知道的。
但是除了这四个，还有两个，那就是取址运算符和 取址运算符 const.
即总共有六个函数。
```
```
class Empty
{
  public:
    Empty(); // 缺省构造函数
    Empty( const Empty& ); // 拷贝构造函数
    ~Empty(); // 析构函数
     Empty& operator=( const Empty& ); // 赋值运算符
     Empty* operator&(); // 取址运算符
     const Empty* operator&() const; // 取址运算符 const
 };
```
```
但是，C++默认生成的函数，只有在被需要的时候，才会产生。即当我们定义一个类，而不创建类的对象时，就不会创建类的构造函数、析构函数等。
```
